package main

import (
	"bytes"
	"fmt"
	"github.com/joho/godotenv"
	"github.com/julienschmidt/httprouter"
	log "github.com/sirupsen/logrus"
	"github.com/urfave/cli"
	"go-redirector/errors"
	"go-redirector/mapping"
	"html/template"
	"net/http"
	"os"
	"strconv"
	"strings"
)

var (
	BUILD_SHA     string
	BUILD_VERSION string
	BUILD_DATE    string
)

// When using the template below, the hidden paragraph at the bottom is unique.
const DEFAULT_HTML_TEMPLATE = `
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>
<body>
<p>The page you reached has moved to <a href="{{.Redirect}}">{{.Redirect}}</a>, please update your bookmarks.</p>
<p>You will be automatically redirected to {{.Redirect}} in <span id="countdown">15</span> seconds.</p>
<p>Or click <a href="{{.Redirect}}">THIS LINK</a> to go there now.</p>
<script type="text/javascript">
	let seconds = 15;

	function countdown() {
		seconds = seconds - 1;
		if (seconds < 0) {
			window.location = "{{.Redirect}}";
		} else {
			document.getElementById("countdown").innerHTML = seconds.toString();
			window.setTimeout("countdown()", 1000);
		}
	}
	countdown();
</script>
<p hidden>Generated by simple-redirector.</p>
</body>
</html>
`

const (
	LOG_LEVEL    = "LOG_LEVEL"
	MAPPING_PATH = "MAPPING_PATH"
	PORT         = "PORT"

	DEFAULT_LOG_LEVEL = log.DebugLevel
	DEFAULT_MAPPING_PATH = "./redirect-map.yml"
	DEFAULT_TEMPLATE_PATH = "./html.tpl"
	DEFAULT_PORT = 8080
)

type Config struct {
	LogLevel     log.Level
	MappingPath  string
	templateFile string
	template     *template.Template
	Port         int
	MappingsFile *mapping.MappingsFile
}

func (c *Config) setPort(port string) {
	if port != "" { // use right away
		c.SetPort(port)
	} else if port := os.Getenv(PORT); port != "" {
		c.SetPort(port)
	}
}

func (c *Config) setMappingFile(filePath string) {
	if filePath != "" {
		c.MappingPath = filePath  // change it
	}

	// use the mapping file
	if mappingFile, err := mapping.LoadMappingFile(c.MappingPath); err != nil {
		log.Errorf("Bad mapping file: %v", err)
		os.Exit(errors.EXIT_CODE_BAD_MAPPING_FILE)
	} else {
		c.MappingsFile = mappingFile
	}
}

func (c *Config) setLogLevel(logLevel string) {
	if logLevel != "" {
		if level, err := log.ParseLevel(logLevel); err != nil {
			log.Errorf("Error: %v", err)
			os.Exit(errors.EXIT_CODE_INVALID_LOGLEVEL)
		} else {
			c.LogLevel = level
		}
	}
}

func (c *Config) SetTemplateFromFile(templateFile string) {
	useBuiltIn := func() {
		template := template.New("default")
		if tpl, err := template.Parse(DEFAULT_HTML_TEMPLATE); err != nil {
			log.Fatalf("Could not read template file [%s]", templateFile)
			os.Exit(errors.EXIT_CODE_TPL_ERROR)
		} else {
			c.template = tpl
		}
	}

	useFile := func() {
		c.templateFile = templateFile
		if tpl, err := template.ParseFiles(templateFile); err != nil {
			log.Fatalf("Could not read template file [%s]", templateFile)
			os.Exit(errors.EXIT_CODE_TPL_NOT_FOUND)
		} else {
			c.template = tpl
		}
	}

	if templateFile == "" {
		useBuiltIn()
	} else {
		useFile()
	}
}

func (c *Config) SetPort(port string) {
	if aPort, err := strconv.Atoi(port); err != nil {
		os.Exit(errors.EXIT_CODE_BAD_PORT)
	} else {
		c.Port = aPort
	}
}

func setLogLevel() (level log.Level) {
	var err error

	if logLevel := os.Getenv(LOG_LEVEL); len(logLevel) <= 0 {
		return DEFAULT_LOG_LEVEL
	} else {
		if level, err = log.ParseLevel(logLevel); err == nil {
			log.SetLevel(level)
			return
		} else {
			log.Errorf("Incorrect Log Level set. Level %s is non existent", level)
			os.Exit(errors.EXIT_CODE_CONFIG_ERROR)
			return
		}
	}
}

func setMappingPath() string {
	if logPath := os.Getenv(MAPPING_PATH); len(logPath) <= 0 { // if not set give default
		return DEFAULT_MAPPING_PATH
	} else {
		return logPath
	}
}

func NewConfig() *Config {
	logLevel := setLogLevel()
	mappingPath := setMappingPath()

	return &Config{
		LogLevel:    logLevel,
		MappingPath: mappingPath,
		Port: DEFAULT_PORT,
	}
}

/**
Loads ENV from file starting from HOME, then to local directory.
Then creates a config object.
 */
func LoadEnv() *Config {
	// env info
	local := fmt.Sprintf("./.env")
	home := fmt.Sprintf("%s/%s", os.Getenv("HOME"), ".env")

	loadEnv := func(fileName string) bool {
		// load env file first, try home
		if _, err := os.Stat(fileName); err == nil {
			if err := godotenv.Load(fileName); err != nil {
				log.Fatalf("Error loading .env file %s", fileName)
			}
			return true
		}

		return false
	}

	if !loadEnv(home) {  // load from home
		loadEnv(local) // load local, else move on
	}

	return NewConfig()
}

type FastServer struct {
	Config *Config
	MappingFile *mapping.MappingsFile
}

func (f *FastServer) RenderTemplate(mappingData mapping.Mapping) (string, error) {
	var tpl bytes.Buffer
	if err := f.Config.template.Execute(&tpl, mappingData); err != nil {
		log.Fatalf("Encountered issues rendering template.")
		return "", err
	} else {
		return tpl.String(), nil
	}
}

func (f *FastServer) notFoundHandler(w http.ResponseWriter, r *http.Request) {
	host := f.parseHost(r.Host)
	log.Infof("Returning 404 for requested page [%s%s], by remote client [%s] with user-agent: [%s]",
		host, r.RequestURI, r.RemoteAddr, r.Header.Get("User-Agent"),
	)
	w.WriteHeader(http.StatusNotFound)
}

func (f *FastServer) mappingHandler(w http.ResponseWriter, r *http.Request) {
	host := f.parseHost(r.Host)
	if mappingFile, err := f.MappingFile.Get(host); err != nil {
		log.Infof("Request not found for [%s%s], remote client [%s] with user-agent: [%s]",
			host, r.RequestURI, r.RemoteAddr, r.Header.Get("User-Agent"),
		)
		// No content, just hang up with a http code right now.
		w.WriteHeader(http.StatusNotFound)
	} else {
		log.Infof("Redirecting to [%s%s] from [%s] for remote client [%s] with user-agent: [%s]",
			mappingFile.Redirect, r.RequestURI, host, r.RemoteAddr, r.Header.Get("User-Agent"),
		)

		content, renderError := f.RenderTemplate(mappingFile)
		if renderError != nil {
			log.Error(renderError)
			fmt.Fprint(w, renderError)
		} else {
			if _, err := fmt.Fprint(w, content); err != nil {
				log.Error(err)
			}
		}
	}
}


/**
Since go1.6 we should be able to do concurrent read on a map.
NOTE: concurrent map write see above
 */
func (f *FastServer) index(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
	//w.Header().Add("Content-Type", "text/html")

	if r.RequestURI == "/favicon.ico" {
		f.notFoundHandler(w, r)
	} else {
		f.mappingHandler(w, r)
	}
}

func (f *FastServer) parseHost(host string) string {
	if strings.Contains(host, ":") {
		return strings.Split(host, ":")[0]
	} else {
		return host
	}
}


func (f *FastServer) Serve(port int) error {
	router := httprouter.New()
	router.GET("/*path", f.index)

	if err := http.ListenAndServe(fmt.Sprintf(":%d", port), router); err != nil {
		return err
	}

	return nil
}

func NewFastServer(config *Config, mappingFile *mapping.MappingsFile) *FastServer {
	return &FastServer{config, mappingFile}
}

func Run(args []string) {
	var AppCommands = []cli.Command{
		{
			Name:    "run",
			Aliases: []string{"r"},
			Usage:   "run simple redirector",
			Flags: []cli.Flag{
				cli.StringFlag{
					Name:  "log-level, l",
					Usage: "Log level of the app `LOG_LEVEL`",
				},
				cli.StringFlag{
					Name:  "file, f",
					Usage: "Use the mapping file specified",
				},
				cli.StringFlag{
					Name:  "template, t",
					Usage: "Use the specified golang template file, otherwise rely on app provided html",
				},
				cli.StringFlag{
					Name:  "port, p",
					Usage: "port to listen on, defaults to 8080",
				},
			},
			Action: func(c *cli.Context) error {
				config := LoadEnv()  // we load env variable settings first, commandline params may override
				// set log-level, which possibly can override any existing log-level
				config.setLogLevel(c.String("log-level"))
				config.SetTemplateFromFile(c.String("template"))
				config.setMappingFile(c.String("file"))
				config.setPort(c.String("port"))

				log.SetLevel(config.LogLevel)
				// Set format to json to help devops out
				log.SetFormatter(&log.JSONFormatter{})

				log.Infof("Loaded [%d] redirect mappings.", len(config.MappingsFile.Mappings))
				log.Infof("Running server on port [%d].", config.Port)
				server := NewFastServer(config, config.MappingsFile)
				return server.Serve(config.Port)
			},
		},
	}

	app := cli.NewApp()
	app.Name = "simple-redirector"
	app.Usage = "simple-redirector"
	app.Commands = AppCommands
	app.Version = fmt.Sprintf("info\n version: %s\n commit: %s\n built: %s",
		BUILD_VERSION, BUILD_SHA, BUILD_DATE)

	// Bail if any errors
	err := app.Run(args)
	if err != nil {
		log.Fatalf("Exiting due to error: %s", err)
	}
}

func main() {
	Run(os.Args)
}
